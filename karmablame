#!/usr/bin/perl

use 5.12.2;
use warnings;

use Cwd;
use Data::Dumper;

sub main {
    my @argv = @_;

    my $blames = blame_git_tree($argv[0]);

    print Dumper($blames);
}

sub blame_git_tree {
    my $git_dir = shift;

    my $cwd = cwd();
    chdir $git_dir;

    my @git_files = split /\n/, `git ls-files`;
    my ($count, $total) = (0, scalar @git_files);

    my %blames = ();

    foreach my $file (@git_files) {
        next if -B $file && $total--;
        $blames{$file} = blame_file($file);

        $count++;
        print "Processed $count/$total\r";
    }
    print "\n";

    chdir $cwd;

    return \%blames;
}

sub blame_file {
    my $file = shift;

    my @blocks = ();
    my @blames = `git blame -w --porcelain $file`;

    while (my ($block, $cursor) = read_blame_block(@blames)) {
        push @blocks, $block;
        splice @blames, 0, $cursor;
    }

    return \@blocks;
}

sub read_blame_block {
    my (@lines) = @_;

    my $block = {
        meta => {},
        lines => [],
    };
    my $cursor = 0;
    my $next_line_number = -1;
    foreach my $line (@lines) {
        chomp $line;

        if ($line =~ /^([a-f0-9]+)\s(\d+)\s(\d+)(?:\s(\d+))?$/) {
            last if $4 && $block->{length};
            $block->{sha} = $1;
            $next_line_number = $2;
            $block->{length} = $4 if $4;
        } elsif ($line =~ /^([a-z-]+)(?:\s(.*))?$/) {
            $block->{meta}{$1} = $2;
        } elsif ($line =~ /^\t(.*)/) {
            push @{ $block->{lines} }, {
                num => $next_line_number-0,
                text => $1,
            }
        } else {
            die "Cannot parse line $line"
        }

        $cursor += 1;
    }

    return $cursor ? ($block, $cursor) : ();
}

main(@ARGV);

1;

#!/usr/bin/perl

use 5.12.2;
use warnings;

my ($SRC_DIR) = @ARGV;

`mkdir -p dest`;
my $PWD = `pwd`;
chomp $PWD;
my $DEST_DIR = "$PWD/dest";
say $DEST_DIR;

chdir $SRC_DIR;

my @git_files = `git ls-files`;

my $count = 0;
my $total = scalar @git_files;

foreach my $file (@git_files) {
    chomp $file;
    next if -B $file;

    my $dir = `dirname $file`;
    my @blocks = ();
    my @blame = `git blame -w --porcelain $file`;

    while (my ($block, $read) = read_blame_block(@blame)) {
        push @blocks, $block;
        splice @blame, 0, $read;
    }
    print "processed $count/$total\r";
    $count +=1;
}
print "\n";

sub read_blame_block {
    my (@lines) = @_;

    my $block = {
        meta => {},
        lines => [],
    };
    my $cursor = 0;
    my $next_line_number = -1;
    foreach my $line (@lines) {
        chomp $line;

        if ($line =~ /^([a-f0-9]+)\s(\d+)\s(\d+)(?:\s(\d+))?$/) {
            last if $4 && $block->{length};
            $block->{sha} = $1;
            $next_line_number = $2;
            $block->{length} = $4 if $4;
        } elsif ($line =~ /^([a-z-]+)(?:\s(.*))?$/) {
            $block->{meta}{$1} = $2;
        } elsif ($line =~ /^\t(.*)/) {
            push @{ $block->{lines} }, {
                num => $next_line_number-0,
                text => $1,
            }
        } else {
            die "Cannot parse line $line"
        }

        $cursor += 1;
    }

    return $cursor ? ($block, $cursor) : ();
}
